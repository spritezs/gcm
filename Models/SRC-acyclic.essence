
given dataset : sequence of (set of int, int)

letting n be max([ x | (_, (xs, _)) <- dataset, x <- xs ])
letting options be domain int(1..n)

letting nbObservations be |dataset|

find omitList : sequence (size nbObservations) of bool

$ (i,j) means i is preferred to j
find rel1 : relation (minSize 1, irreflexive) of (options * options)

$ For each entry in the dataset, we will record the survivors after applying rel1.
$ adding minSize 1 to the set here would disallow RC solutions
find survivor1 : sequence (size nbObservations) of set of options

find rel2 : relation (minSize 1, irreflexive) of (options * options)

$ For each entry in the survivor1 set, we will record the survivors after applying rel2.
$ size 1 - single valued choice
find survivor2 : sequence (size nbObservations) of set (size 1) of options

such that
    forAll row : int(1..nbObservations) .
        ((omitList(row) /\ !(dataset(row)[2] in survivor1(row))) \/
        (!omitList(row) /\ (dataset(row)[2] in survivor1(row))))  /\
        $ Element survives if it is not dominated by any other element of the set.
        forAll x in dataset(row)[1] .
            x in survivor1(row) <-> forAll y in dataset(row)[1] . !rel1(y, x)

such that
    forAll row : int(1..nbObservations) .
        ((omitList(row) /\ !(dataset(row)[2] in survivor2(row))) \/
        (!omitList(row) /\ (dataset(row)[2] in survivor2(row)))) /\ 
        forAll x in survivor1(row) .
            x in survivor2(row) <-> forAll y in survivor1(row) . !rel2(y, x)


$ Distance score is min number of elements to be removed from dataset to comply perfectly with model.
find score : int(0..nbObservations)
such that score = sum row : int(1..nbObservations) . toInt(omitList(row))

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$ rel1 acyclic

$ path(x,y) iff there is a path from x to y
find path1 : relation of (options * options)
 
$ edges are paths
such that forAll (x,y) in rel1, x!=y . path1(x,y)
 
$ path from x->y AND y->z IMPLIES x->z
such that forAll x,y,z : options . (path1(x,y) /\ path1(y,z)) -> path1(x,z)

$ rel is acyclic
such that forAll x : options . !path1(x,x)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$ rel2 acyclic

$ path(x,y) iff there is a path from x to y
find path2 : relation of (options * options)
 
$ edges are paths
such that forAll (x,y) in rel2, x!=y . path2(x,y)
 
$ path from x->y AND y->z IMPLIES x->z
such that forAll x,y,z : options . (path2(x,y) /\ path2(y,z)) -> path2(x,z)

$ rel is acyclic
such that forAll x : options . !path2(x,x)

$ sol1
$ sol2

$ sol1.rel1
$ sol1.rel2

$ sol2.rel1
$ sol2.rel2


$ def dominates(sol1, sol2):
$     and([ sol1.rel1 subsetEq sol2.rel1
$         , sol1.rel2 subsetEq sol2.rel2
$         , or([ sol1.rel1 subset sol2.rel1
$              , sol1.rel2 subset sol2.rel2
$              ])
$         ])



